#

### 分布式锁

> 什么是分布式锁？

分布式锁是在分布式系统之间，同步访问共享资源的一种解决方式。详细来说：在分布式环境下，一个系统在访问共享资源时，会协调其他系统，然后获得访问权限，，其他系统必须等权限释放后才能去尝试获取权限操作共享资源。

> 如何实现分布式锁

1. 基于mysql数据库实现分布式锁
2. 基于redis实现分布式锁

其他的还有基于zookeeper，etcd等等

> 分布式锁经常出现的问题是什么?

1. 可用问题: 首先设计分布式锁它必须是可用的，这是锁执行的基础
2. 死锁问题：因为某些问题，两个或多个进程都在互相等待锁的释放，导致了程序的阻塞
3. 脑裂问题：因为某些问题，集群发生了脑裂，两个或多个进程同时拿到了同一把锁

> 基于关系型数据库实现的分布式锁?

做法如下：首先通过查询记录是否存在，为了防止幻影读，通过select for update锁住这行数据，然后将查询和插入的sql放在同一个事务中提交。

**tips**: ​

1.  select fro update语句只能用在innodb引擎，并且在BEGIN/COMMIT语句块中，

2. mysql数据库的事务隔离级

   - 读未提交
   - 读提交
   - 可重复读（mysql的默认隔离级别）
   - 串行化

   隔离级别逐步提高，数据库并发性能逐步下降

3. 基于乐观锁方式实现分布式锁

select for update是基于悲观锁来实现的，会一直阻塞到事务提交，为了避免阻塞等待而消耗资源，可采用乐观锁的实现方式

做法如下：在数据库里面增加一个int类型的version字段，在select 获取行记录的同时也获取这个版本号字段，后面在进行更新操作的时候where条件增加刚才查询到的版本号字段，如果版本号相同说明这期间没有被其他事务进行过更新，如果不相同，则被更新过，需要进行异常处理。

> 基于分布式缓存实现分布式锁（基于Redis）

1. 加锁过程：**SET psl  12345 ex 10 nx**

加锁命令和过期时间合在一起是redis 2.6.12新增的命令，nx表示当key存在时不操作，不存在时才进行设置，为了避免死锁，同时会加一个过期时间有ex 和px，分别表示秒和毫秒

2. 解锁过程也就是删除key的过程，设置的时候value是唯一的，为了防止乱删，会使用lua脚本将多条redis命令组成一个原子操作执行

> Redis实现分布式锁的优缺点

*优点*：

1. 性能高效
2. 实现方便
   - 需要注意的是加锁命令和设置过期时间合在一起是redis2.6.12及之后才有的命令，之前版本可用lua脚本进行多条命令的原子操作

*缺点*：

1. 超时时间的不合理设置

超时时间其实很难界定，一旦发生死锁问题，超时时间肯定越短越好，一旦超时时间过长，死锁会阻塞过长时间，但是如果超时时间过短，会导致锁的错误删除或可能锁功能的失效，多个线程持有锁

> Redis官方如何解决集群情况下分布式锁的可靠性

集群情况下可能会因为事务A刚刚获得了分布式锁，此时主节点挂掉，导致分布式锁失效，事务B再次获取到了锁，同时存在多个事务获取到了锁

redis官方实现了RedLock算法来解决这一问题，基本思路是：redis客户端和N个独立的redis实例依次进行加锁操作，加锁完成后，如果超过半数的实例都加锁成功，则此次客户端加锁成功









