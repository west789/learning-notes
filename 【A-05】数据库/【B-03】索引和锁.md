

### 索引常见模型

> 哈希表、有序数组、搜索树
>
> 1. 哈希表： 适用于等值查询的场景，大部分使用数组+链表的数据结构
> 2. 有序数组：适用于静态存储引擎，更新和删除会引起挪动其他数据，造成性能损耗
> 3. 搜索树：二叉搜索树，N叉树

### InnoDB索引模型

> 1. 根据叶子节点的内容，索引分为主键索引（InnoDB中又称为聚簇索引）和非主键索引（InnoDB中又称为二级索引）
> 2. 主键索引和普通索引区别？
>    1. 主键索引只会查找主键这颗B+树
>    2. 普通索引会先查找该普通索引所属的B+树，获取主键，然后回表，在主键B+树获取最终行数据。会多扫描一棵B+数

### 索引维护

> 1. 如果插入的值是追加的记录，则直接追加到最后即可
> 2. 如果插入的值位于值中，则需要挪动其他数据，若该节点已满，则会产生页分裂（新产生一个分页，挪动部分数据过去）
> 3. 相邻两个页如果删除了数据，利用率低，会将页进行合并
> 4. 一般使用自增主键，一方面都是追加操作，另一方面叶子节点占用空间小
> 5. 使用业务逻辑字段做索引场景：
>    1. 只有一个索引
>    2. 该索引是唯一索引

### 索引优化

> 1. 覆盖索引：要查询的字段已经存在于索引中
> 2. 前缀索引：联合索引的最左N个字段或字符串的最左M个字符
> 3. 索引下推：5.6版本以后，减少了回表次数

### Mysql全局锁

> 1. 对整个数据库实例进行加锁，提供加读锁的方法，数据库全局只读，Flush Tables With Read Lock（FTWRL）
>
> 2. 典型应用场景：做全库逻辑备份
> 3. 官方自带逻辑备份工具mysqldump,使用参数-single-transaction，此方法只适用于支持事务数据引擎的库
> 4. 为什么不使用set global readonly=true?
>    1. readonly值会被用来做其他逻辑，比如是主库还是备库
>    2. FTWRL会在客户端异常断开后自动释放读锁，而设置readonly后，客户端退出后，整个库仍然是只读状态，风险较高

### Mysql表锁

> 1. 表锁：lock tables....read/write, 释放有两种方式（1）主动释放，unlock tables (2)客户端断开连接。但是对于InnoDB支持行锁的引擎来说，一般不使用表锁
> 2. 元数据锁：5.5版本引入MDL
>    1. 增删改查操作，加MDL读锁，对表结构做变更，加MDL写锁
> 3. 如何安全的给小表加字段？
>    1. 解决长事务，事务不提交，会一直占据MDL锁，information_schema库的innodb_trx中可以查到当前正在执行的事务
>    2. alter table语句中设定等待时间，该时间内拿到锁更好，拿不到稍后重试

### Mysql行锁

> 1. 两阶段锁：InnoDB事务中，行锁是在需要的时候加上，但并不是不需要了就释放，而是要等到事务结束后才会释放，这就是两阶段锁协议
> 2. 如果事务中需要锁多行，要把最可能造成锁冲突的行尽量往后放，这样可以最大程度降低行锁时间
> 3. 死锁发生时策略？
>    1. 设置死锁等待时间，mysql默认值是50s
>    2. 发起死锁检测，发现死锁时候，主动回滚死锁链条中的事务
> 4. 怎么解决热点行更新时导致的性能问题？
>    1. 关闭死锁检测，确认不会出现死锁，比较不可行
>    2. 控制并发度
>       1. 业务上控制
>       2. 数据库中间件控制
>    3. 还可以将一行改成逻辑上的多行，但是对于业务处理边界条件要求比较高

### Mysql隔离及一致性视图

> 1. InnoDB在实现MVCC时用到的一致性读视图，用于支持RC（读已提交）和RR（可重复读）隔离级别的实现
> 2. Transaction_id和row_trx_id :
>    1. InnDB中每个事务都有一个事务ID，叫transaction_id,它是启动事务时向InnoDB事务系统申请的，值按申请顺序严格递增
>    2. 数据表中每一行记录也可能有多个版本，每个版本有自己的row trx_id
> 3. 一致性视图
>    1. 视图数组和高水位组成
>    2. 视图数组：事务启动时候，活跃的事务ID组成（正在执行还未提交），其中最小值记为低水位
>    3. 高水位：当前系统里创建事务ID的最大值+1
> 4. row trx_id三种情况
>    1. 低水位之前，已提交事务或当前事务自己生成的，当前事务可见
>    2. 高水位之后，未开始事务，不可见
>    3. 低水位和高水位之间：
>       1. 在数组中，不可见
>       2. 不在数组中，可见
> 5. 总结：一个数据版本，对于一个事务视图除了自己更新总是可见，有三种情况：
>    1. 版本未提交，不可见
>    2. 版本已提交，视图创建后提交，不可见
>    3. 版本已提交，视图创建前提交，可见
> 6. 更新数据都是先读后写，这个读都是当前读，另外，select加锁也是当前读，如select....for update

### 普通索引和唯一索引选择

> 1. 查询过程，性能差距微乎其微：
>    1. 普通索引：查找到满足条件的记录后，需要查找下一条记录，直到找到不满足条件的记录
>    2. 唯一索引：查找到满足条件的记录后，就停止查找
> 2. 更新过程
>    1. Change buffer：
>       1. 当需要更新一个数据时，如果这个数据页在内存中，则直接更新数据页，如果不在内存中，则写入change buffer，下次访问这个数据页的时候，将数据页读入内存，执行change buffer与这个页有关的操作
>       2. 更新语句先记录在change buffer中，减少读磁盘，语句执行速度得到明显提升
>    2. 唯一索引：所有更新操作都需要判断是否违反了唯一性约束，因此唯一索引不能使用change buffer
>    3. 插入一条记录，innodb的更新流程：
>       1. 执行的记录数据页在内存中
>          1. 唯一索引，判断查找的位置有没有冲突，没有则插入，语句执行结束
>          2. 普通索引，找到插入的位置，插入记录
>       2. 执行的记录数据页不在内存中
>          1. 将记录的数据页读入内存，判断有没有冲突，没有则插入，语句执行结束
>          2. 将更新记录写入change buffer，执行结束
>    4. 应用场景：写多读少的场景，写完之后被访问到的概率较小，change buffer使用效果最好
>    5. 普通索引和唯一索引在查询性能上没有什么差别，主要是在更新性能上，尽量使用普通索引











































































































