# TCP学习

## TCP基本认识

#### TCP头格式

源端口号、目标端口号、序列号、确认应答号、首部长度、保留位、窗口大小、校验和、紧急指针、数据

![](E:\notes\网络\photo\640.webp)

- 序列号：建立连接时由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次数据就累加一次该数据字节数的大小。**用来解决网络包乱序的问题**
- 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为该序号以前的数据都已经正确接收。**用来解决不丢包的问题**
- 控制位:
  1.  ACK：该位为1时，表示确认应答位有效；TCP规定除了最初连接的SYN包以外，其他情况下该位必须为1
  2. RST：该位为1时，表示TCP连接中出现异常必须强制断开连接
  3. SYN：该位为1，表示希望建立连接，并在序号位进行初始值的设定
  4. FIN：该位为1，表示今后不会再有数据发送，希望断开连接。当通信结束，希望断开连接时，通信双方就可以交换FIN为1的TCP段。



#### 为什么需要TCP协议？TCP协议在那一层

IP层是不可靠的，它不保证网络包的交付，不保证网络包的有序，不保证网络包的完整

TCP是工作在传输层的服务，它能确保接收端接收到的网络包是可靠、完整、有序的

### 什么是TCP

TCP是面向连接的、可靠的、字节流

- 面向连接：一对一才能连接，不能像UDP协议一样，一对多地发送消息，也就是TCP一对多是无法做到的
- 可靠的：无论网络链路中出现怎样的链路变化，TCP可以保证报文能够送达接收端
- 字节流：消息是没有边界的，无论多大的都可以进行传输，并且消息是有序的，当前一个消息还没有收到，即使先收到了后面的消息，也不会扔给应用层处理，同时对重复的报文进行丢弃

### 什么是TCP连接

用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合包括Socket、序列号、窗口大小称为连接

所以，建立一个TCP连接需要客户端与服务端达成三个信息的共识：

- Socket：由IP和端口组成
- 序列号：用来解决乱序问题
- 窗口大小：用来做流量控制

###  如何唯一确定一个TCP连接

TCP四元组可以唯一确定一个连接

**源地址**   **源端口**   **目标地址**  **目标端口**

理论上:

最大TCP连接数=客户端的IP数*客户端的端口数

2^48次方，当然服务端TCP连接数远不能达到理论上限

- 首先是文件描述符的限制，socket都是文件，通过ulimit查看文件描述符数目
- 其次是内存的限制，一个TCP连接都要占用一定的内存，操作系统是有限的

### UDP和TCP有什么区别？分别的应用场景是？

首先解释一个UDP：

UDP不提供复杂的通信机制，是利用IP提供的面向无连接的通信服务

UDP协议非常简单，UDP头只有8个字节，头部格式:



![](E:\notes\网络\photo\641.webp)



源端口号和目标端口号: 用来告诉UDP协议应该把报文发给哪个进程

包长度：首部长度和数据长度之和

校验和：为了提供可靠的UDP首部和数据设计的

### TCP和UDP的区别

1. 连接
   - TCP是面向连接的传输层协议，传输数据前需要建立连接
   - UDP无需建立连接，即刻传输数据
2. 服务对象
   - TCP是一对一的两点服务，即一条连接两个端点
   - UDP支持一对一、一对多、多对多
3. 拥塞控制、流量控制
   - TCP有拥塞控制和流量控制，保证数据的安全性
   - UDP不考虑这些，即便网络非常拥堵，也不影响发送速率
4. 首部开销
   - TCP首部长度较长，会有一定开销，在没有使用选项字段前，是20个字节，如果使用了会更长
   - UDP首部是8个字节，且固定不变，开销较小

### TCP和UDP的应用场景

由于TCP是面向连接的，能保证可靠的数据交付，因此经常用于：

- FTP文件传输
- HTTP/HTTPS

由于UDP面向无连接，随时发送数据，本身简单高效，经常用于:

- 包总量较少的通信。DNS、SNMP等
- 视频音频等多媒体通信
- 广播通信

### 为什么UDP头部没有首部长度字段，而TCP头部有首部长度字段

TCP头部有可变长的选项字段，UDP头部是不会变化的，无需多个字段去记录

### 为什么UDP头部有包长度字段，TCP头部没有

TCP如何计算负载数据长度:

**TCP数据的长度=IP总长度-IP首部长度-TCP首部长度**

最大可能是UDP为了保证首部长度是4字节的整数倍，补充了包长度字段

## TCP建立连接

> TCP三次握手和状态变化

![](E:\notes\网络\photo\642.webp)

一开始，通信双方即客户端服务端都处于closed状态，服务端监听某一端口处于Listen状态。

第一个报文-SYN报文

- 客户端会随机初始化一个的序号client-isn,并将此值填充到TCP的首部序号字段，同时设置SYN标志位为1，标识这是一个SYN报文，接着把报文发送给服务端，表示像服务端发起连接，之后客户端处于SYN_SENT状态

第二个报文-SYN+ACK报文

- 服务端收到客户端的SYN报文后，服务端也会随机初始化一个序号，并将此值填充到TCP首部的序号字段中，将确认应答字段设置为client_isn+1，同时将标志位的SYN和ACK设置为1。接着把报文发送给客户端，不携带应用层数据，之后服务端处于SYN-RCVD状态

第三个报文-ACK报文

- 客户端收到服务端的报文后，还要像服务端回应最后一个应答报文，首先应答报文TCP首部的ACK标志位设置为1，确认应答字段设置为server_isn+1,最后将报文发送给服务端，次报文可以携带要发送的数据，之后客户端处于ESTABLISHED状态
- 服务端收到客户端的应答报文后，也处于ESTABLISHED状态，

一旦三次握手完成，双方都处于ESTABLISHED状态，此连接就建立完成，客户端和服务端就可以相互发送数据了。

### 如何在Linux中查看TCP状态？

![](E:\notes\网络\photo\643.webp)

### 为什么是三次握手?而不是二次、四次？

- 三次握手可以阻止历史连接的重复初始化
- 三次握手可以同步双方的初始序列号
- 三次握手可以避免资源浪费

小结：

TCP建立连接时，通过三次握手可以阻止历史连接的重复建立，可以帮助双方同步初始化序列号，可以避免资源浪费

不使用两次握手和四次握手的原因:

- 两次握手：无法阻止历史连接的建立，无法确保双方同步初始化的序列号，无法避免资源浪费
- 四次握手：可用性上四次握手也是可以的，但是三次握手已经是理论上的最少可靠连接建立了，无需更多通信次数

### 为什么客户端和服务端的初始序列号ISN是不相同的?

因为网络中的报文会延迟、会复制重发、也有可能丢失，我问问了避免不同连接之间的相互影响，客户端和服务端初始序列号是随机且不同的。

### 初始序列号ISN是如何随机产生的？

起始ISN是基于时钟的，每4ms+1，转一圈要4.55个小时

ISN = M+F(localhost,localport,remotehost,remoteport)

### 既然IP层会分片，为什么TCP层还需要MSS？

两个概念：MTU和MSS

- MTU：一个网络包的最大长度，以太网中一般为1500字节
- MSS：除去IP和TCP头部后，一个网络包所能容纳的TCP数据的最大长度

## TCP连接断开

客户端主动关闭连接----TCP四次挥手

![](E:\notes\网络\photo\644.webp)

- 客户端打算关闭连接，此时会发送一个TCP首部FIN标志位为1的报文，即FIN报文，之后客户端进入FIN_WAIT_1状态
- 服务端收到该报文后，就向客户端发送ACK应答报文，接着服务端进入CLOSED_WAIT状态
- 客户端收到ACK应答报文后，接着处于FIN_WAIT_2状态
- 等待服务端处理完数据，也向客户端发送FIN报文，之后服务端处于LAST_ACK状态
- 客户端收到FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态
- 服务端收到ACK报文后，进入CLOSE状态，至此服务端已经完成连接的关闭
- 客户端经过2MSL一段时间后，自动进入CLOSE状态，至此客户端完成连接的关闭

每个方向上都已一个FIN和ACK，因此被称为四次挥手

主动关闭连接的，才有TIME_WAIT状态

### 为什么挥手需要四次

服务端通常需要等待完成数据的发送和处理，所以ACK和FIN需要分开发送，从而比三次握手多了一次

### 为什么TIME_WAI等待的时间是2MSL

MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间，报文将被丢弃。

### MSL和TTL区别

MSL单位是时间，TTL是经过的路由数。所以MSL应该要大于等于TTL消耗为0的时间，以确保报文自然消亡

TIME_WAIT是2MSL

被动方没有收到断开连接方最后的ACK后，就会超时重发FIN,另一方收到FIN，就会重发ACK，一来一去正好2个MSL。

2MSL是从客户端接收到FIN后发送ACK开始计时的，如果2MSL时间内收到了超时重传的FIN，2MSL将会重新计时

在linux系统中，2MSL默认是60s，那么1个MSL就是30s

### 为什么需要TIME_WAIT状态？

- 防止具有相同四元组的旧的数据包被接收到
- 保证被动关闭连接的一方能够正确的关闭

### TIME_WAIT过多有什么危害

- 一是内存占用
- 而是对端口资源的占用，一个TCP连接至少需要一个本地端口

## Socket编程

基于TCP协议的客户端和服务端工作

![](E:\notes\网络\photo\645.webp)

服务端监听socket和真正传数据的socket是两个

### listen时候参数backlog的意义

linux内核中会维护两个队列：

- 未完成连接的队列（SYN队列）：接收到一个SYN建立连接请求，处于SYN—RCVD状态
- 已完成连接队列（ACCEPT队列）：已完成TCP三次握手，处于ESTABLISH状态

### accept发送在三次握手的哪一步

客户端connect成功返回是在第二次握手，服务端accept返回在第三次握手成功之后