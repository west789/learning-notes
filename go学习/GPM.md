# Golang的协程调度器原理及GMP

## Golang调度器的由来

- 早期的操作系统每个程序就是一个进程，直到一个进程执行完，另一个进程才可以执行，这就是"单进程时代"。早期的单进程操作系统面临2个问题

  - 单一的执行流程，计算机只能一个任务一个任务处理
  - 进程阻塞所带来的的cpu时间的浪费

  后来操作系统就有了最早的并发能力：**多进程并发**

- 多进程/多线程时代有了调度需求

  在多进程/多线程操作系统中，解决了阻塞问题，一个进程阻塞，cpu可以立刻切换到其他进程中执行，而且调度cpu的算法可以保证在运行的进程都可以分配到cpu的的运行时间片。宏观上来看，似乎多个进程被同时运行。但是新的问题又出现了，进程拥有太多的资源，进程的创建、切换、销毁都会占用很长的时间，cpu虽然利用起来了，但是很大一部分被用来进行进程调度了。

  多线程开发会使得涉及变得更加复杂，要考虑很多同步竞争问题，如锁和竞争冲突等。

- 协程提高cpu的利用率

  多进程、多线程提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程时不现实的，因为会消耗大量的内存（进程虚拟内存会占用4GB 32位，线程大约是4MB）,大量的进程和线程带来了新的问题：

  - 高内存占用
  - 调度的高消耗cpu

  看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。

   之后，我们就看到了有3种协程和线程的映射关系

  goroutine特点：

  - 占用内存更小
  - 调度更灵活(runtime调度)

## Goroutine调度器GMP模型设计思想

### （1）GMP模型

线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上

![](.\photo\GMP.png)

1. **全局队列** : 存放等待运行的G
2. **P的本地队列** ：同全局队列类似，存放的也是等待运行的G，存放的数量有限，不超过256个。新建G'时优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列
3. **P列表** ：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个
4. **M** :  线程想要运行任务就得获取P，从P的本地队列获得G，P队列为空时，M也会尝试从全局G队列拿一批G放到P的本地队列，或从其他P本地队列偷一半G放到自己的P本地队列。M运行G，G执行之后，M会从P获取下一个G不断重复下去。

**Goroutine调度器和OS调度器是通过M结合起来的，每个M代表一个内核线程，OS调度器负责把内核线程分配到CPU上运行**

> 有关P和M的个数

1. P的数量
   - 由启动时的环境变量$GOMAXPROCS或者runtime的方法GOMAXPROCS()决定
2. M的数量
   - go语言本身的限制：go程序启动时会设置M的最大数量，默认10000，内核很难达到这么多线程，可以忽略
   - runtime/debug中的SetMaxThreads，设置M的最大数量
   - 一个M阻塞了，会创建新的M

> P和M何时会被创建

1. P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P
2. M何时创建：没有足够的M来关联P并运行其中可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，没有空闲的M，就会创建新的M。

### 调度器的设计策略

![](.\photo\gofunc.jpeg)

> M0 

go程序启动时创建的编号为0的线程，这个M对应的实例会在全局变量runtime.m0中，不在堆上分配，M0负责初始化操作和启动第一个G，之后M0和其他M一样

> G0

G0是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度G，G0不指向任何可执行的函数，每个M都会有一个自己的G0，在调度或系统调用时都会使用G0的栈空间，全局变量的G0是M0的G0

```go
package main
import "fmt"
func main() {
    fmt.Println("Hello, world")
}
```

1. runtime创建最初的线程m0和goroutine g0，并把两者关联
2. 调度器初始化：初始化m0，栈、垃圾回收，以及P列表
3. 代码经过编译后，runtime.main会调用main.main，程序启动时runtime.main创建goroutine,称为main goroutine, 将main.goroutine加入到P的本地队列
4. 启动m0，m0绑定了P，会从P的本地队列获取G，获取到main goroutine
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，重复下去，知道main.main退出，runtime.main执行defer和panic处理，或调用runtime.exit退出程序

[GMP模型参考链接](https://www.kancloud.cn/aceld/golang/1958305)





