# Golang基础模块信息

#### Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量

> 1. 使用channel通道进行同步
> 2. 使用cas原子操作    

#### 无缓冲Chan的发送和接收是否同步

> 是同步的，有缓冲是不同步的
>
> 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到数据被发送
>
> 有缓冲时，当缓冲满时，发送阻塞，当缓冲空时，接收阻塞

#### Golang并发机制以及它所使用的CSP并发模型．

> CSP并发模型，CSP直译是通信顺序过程，是上世纪七十年代提出的一种并发模型，用来描述两个独立的并发实体通过共享管道进行通信的并发模型。go提出的通过通信来共享内存也是基于此。golang利用CSP作为了并发模型的基础，实现方式是goroutine+channel。其中goroutine是实际并发的实体，它的执行过程因为有了GMP的调度，具有高并发，高性能的特点。
>
> channel是通道的意思，一个实体将消息发送到通道中，另一个实体监听通道获取消息，两个实体是匿名的，存在于不同的进程中，因此是解耦的

#### Golang中常用的并发模型

> 1. 通过channel通知实现并发控制
>
> 2. 通过sync.WaitGroup实现并发控制
>
> 3. Go1.7以后引入Context上下文实现并发控制
>
>    context包主要用来处理多个goroutine之间共享数据，以及管理多个goroutine

#### Go中对nil的Slice和空Slice的处理是一致的吗

> 不一致，var a []int 是nil Slice，只是声明，没有初始化
>
> a := []int 或 a := make([]int) 底层是空的，不是nil只是没有值

#### 协程和线程和进程的区别

#### Golang的内存模型中为什么小对象多了会造成GC压力

> 小对象过多会造成GC三色法消耗过多的cpu，减少小对象的分配

#### Go中数据竞争问题怎么解决

> 1. sync.Mutex加锁解决
> 2. cas原子操作解决
> 3. channel通道解决

#### 什么是channel，为什么它可以做到线程安全

> channel 是golang的核心类型之一，通过channel实现了csp并发模型，可以理解为管道，一个先进先出的队列。go中的channel有两类：1. 无缓冲通道，发送阻塞直到数据被接收，接收阻塞直到数据被发送 2. 有缓冲通道 缓冲区满发送阻塞，缓冲区为空接收阻塞。发送数据到channel和从channel中获取数据都是原子性的操作，因此是并发安全的

#### Golang垃圾回收算法

> golang 采用并发的“三色标记清除”垃圾回收算法，整个GC过程实际上就是标记清除的过程，因为标记-清除需要STW，golang通过三色标记和写屏障进行了优化，以此减少STW的时间。Golang的GC主要有以下四个步骤:
>
> 1. 栈扫描，开始时需要STW，所有对象刚开始都为白色
> 2. 从root开始，找到所有可达对象，标记为灰色，放入待处理队列
> 3. 遍历所有灰色对象，找到所有可达对象标记为灰色，并将当前对象标记为黑色
> 4. 重复步骤3，直到灰色队列为空，此时，所有标记为白色的都是需要清除的。golang的三色标记减少了STW的时间，得益于“on-the-fly”，标记是不需要STW，是并发进行执行的，
>
> GC优化的核心是减少STW的时间

#### GC的触发条件

> GC的触发有两种形式：
>
> 1. 主动触发，通过调用runtime.GC手动触发
> 2. 被动触发，又分为两种情况:
>    - 当系统监控，当超过2min没有进行GC，强制触发GC
>    - 使用步调算法，控制内存增长比例，当达到内存分配达到一定比例触发GC

#### Go的GPM如何调度

#### 并发编程概念是什么

> 并行是在不同的实体上执行多个任务，并发是在同一实体上执行多个任务。并行是真正意义上的同时执行。
>
> 并发编程是在同一个实体上执行多个任务的编程手段，核心目标是提高cpu核的利用率。

#### Go语言的栈空间管理是怎么样的

> 待补充

#### Goroutine和Channel的作用分别是什么

#### 怎么查看Goroutine的数量

> GOMAXPROCS控制的是未被阻塞的最大goroutine数量

#### Go中的锁有哪些

> 互斥锁，读写锁，sync.Map安全锁

#### 怎么限制Goroutine的数量

#### Channel是同步的还是异步的

> 无缓冲通道是同步的，同步的channel不能在一个goroutine发送和接收
>
> 有缓冲通道是异步的，此时channel存在三种状态:
>
> 1. 零值channel
> 2. 非零值但已关闭
> 3. 非零值且尚未关闭

#### Goroutine和线程的区别

#### Go的Struct能不能比较

> 相同的struct类型可以比较
>
> 不同的struct类型不可比较，编译不通过

#### Go的defer原理是什么

> defer是延迟的意思，go中用defer修饰的函数将会被延迟执行，主要用于处理连接关闭，资源释放的问题。使用defer有以下需要注意的地方:
>
> 1. 多个defer的调用是先进后出的，可以理解为栈的结构
> 2. defer和return的同时出现，如果返回参数是命名参数，因为return不是原子性语句，含有defer和return的函数执行分为三步
>    - 赋值给返回参数
>    - 执行defer函数
>    - 执行空return
> 3. defer函数的参数在入栈时就已经确定